## This module is part of num_crunch: https://github.com/willi-kappler/num_crunch
## Written by Willi Kappler, License: MIT
##
## The NCNode data structure is defined here, the main entry point for starting the
## execution of the code that runs on all nodes.
##
## The user has to implement this method: "ncProcessData()".
## The other method "ncInit()" may be implemented if needed.
##
## These two methods are defined for the NCNodeDataProcessor data structure
## that the user has to inherit from / implement.
##

# Nim std imports
import std/typedthreads

from std/os import sleep
from std/strformat import fmt
from std/net import Port

# External imports
from chacha20 import Key

# Local imports
import private/nc_message
import nc_config
import nc_log
import nc_nodeid
import nc_common

type
    NCNode* = object
        ## configuration items for each node.
        serverAddr: string
        serverPort: Port
        key: Key # Secret key for encrypting the messages
        heartbeatTimeout: uint16 # In seconds
        nodeId: NCNodeID # This id will be generated by the server

    NCNodeDataProcessor* = ref object of RootObj

var ncNodeInstance: ptr NCNode

var ncDPInstance: ptr NCNodeDataProcessor

method ncInit(self: var NCNodeDataProcessor, data: seq[byte]) {.base.} =
    ## Initialization code for each node.
    ## This is called when the node first contacts the server and receives
    ## a new and unique node id.
    ## This method doesn't have to be implemented if not needed.
    discard

method ncProcessData(self: var NCNodeDataProcessor, data: seq[byte]): seq[byte] {.base.} =
    ## This method mus be implemented by the user of this library.
    ## It received new data from the server, processed it and returns the processed data
    ## that will be sent back to the server.
    quit("You must override this method: processData")

proc ncSendHeartbeat() {.thread.} =
    ## This is the heartbeat thread that sends a heartbeat to the server so
    ## that the server knows that this node is still alive.
    ## If the hearbeat message is no longer sent to the server, the server
    ## calls the "ncMaybeDeadNode()" method, that the user has defined.
    ncDebug("sendHeartbeat()", 2)
    let timeOut = int(ncNodeInstance.heartbeatTimeout * 1000)
    let serverAddr = ncNodeInstance.serverAddr
    let serverPort = ncNodeInstance.serverPort
    let key = ncNodeInstance.key
    let nodeId = ncNodeInstance.nodeId

    while true:
        sleep(timeOut)

        # Send heartbeat message to server.
        ncDebug(fmt("sendHeartbeat(), Node {nodeId} sends heartbeat message to server"))
        let serverResponse = ncSendHeartbeatMessage(serverAddr, serverPort, key, nodeId)

        case serverResponse.kind:
            of NCNodeMsgKind.quit:
                ncInfo("sendHeartbeat(), All work is done, will exit now")
                break
            of NCNodeMsgKind.ok:
                # Everything is fine, nothing more to do.
                discard
            else:
                ncError(fmt("sendHeartbeat(), Unknown response: {serverResponse.kind}"))
                break

proc ncRunNode*() =
    ## This is the entrypoint for running the node and thus the user defined code.
    let serverAddr = ncNodeInstance.serverAddr
    let serverPort = ncNodeInstance.serverPort
    let key = ncNodeInstance.key

    let serverResponse = ncRegisterNewNode(serverAddr, serverPort, key)

    case serverResponse.kind:
        of NCNodeMsgKind.welcome:
            let (nodeId, initData) = ncFromBytes(serverResponse.data, (NCNodeID, seq[byte]))
            ncInfo(fmt("ncRunNode(), Got new node id: {nodeId}"))
            ncNodeInstance.nodeId = nodeId
            ncDPInstance[].ncInit(initData)
        of NCNodeMsgKind.quit:
            ncInfo("ncRunNode(), All work is done, will exit now")
            return
        else:
            ncError(fmt("ncRunNode(), Unknown response: {serverResponse.kind}"))
            return

    var hbThreadId: Thread[void]
    createThread(hbThreadId, ncSendHeartbeat)

    let nodeId = ncNodeInstance.nodeId

    while true:
        let serverResponse = ncNodeNeedsData(serverAddr, serverPort, key, nodeId)

        case serverResponse.kind:
            of NCNodeMsgKind.quit:
                ncInfo("ncRunNode(), All work is done, will exit now")
                break
            of NCNodeMsgKind.newData:
                ncDebug("ncRunNode(), Got new data to process")

                if serverResponse.data.len() == 0:
                    ncDebug("ncRunNode(), no more data to process, waiting for quit message")
                    sleep(60 * 1000)
                else:
                    let processedData = ncDPInstance[].ncProcessData(serverResponse.data)
                    ncDebug("ncRunNode(), Processing done, send result back to server", 2)
                    let serverResponse = ncSendProcessedData(serverAddr, serverPort, key, nodeId, processedData)

                    case serverResponse.kind:
                        of NCNodeMsgKind.quit:
                            ncInfo("ncRunNode(), All work is done, will exit now")
                            break
                        of NCNodeMsgKind.ok:
                            # Everything is fine, nothing more to do.
                            discard
                        else:
                            ncError(fmt("ncRunNode(), Unknown response: {serverResponse.kind}"))
                            break
            else:
                ncError(fmt("ncRunNode(), Unknown response: {serverResponse.kind}"))
                break

    ncDebug("ncRunNode(), Waiting for other thread to finish...")

    # Try to join the heartbeat thread.
    if not hbThreadId.running():
        joinThread(hbThreadId)

    ncInfo("ncRunNode(), free memory")

    reset(ncNodeInstance.serverAddr)
    reset(ncNodeInstance.key)
    deallocShared(ncNodeInstance)
    deallocShared(ncDPInstance)

    ncInfo("ncRunNode(), Will exit now!")

proc ncInitNode*(dataProcessor: NCNodeDataProcessor, ncConfig: NCConfiguration) =
    ## Initializes the node with the given configuration.
    ncInfo("ncInitNode(config)")

    ncNodeInstance = createShared(NCNode)
    ncNodeInstance.serverPort = ncConfig.serverPort
    ncNodeInstance.serverAddr = ncConfig.serverAddr
    # Cast key from string to array[32, byte] for chacha20 (32 bytes)
    let keyStr = ncConfig.secretKey
    ncDebug(fmt("ncInitNode(config), Key length: {keyStr.len()}"))
    assert(keyStr.len() == len(Key), "ncInitNode(config), Key must be exactly 32 bytes long")
    let key = cast[ptr(Key)](unsafeAddr(keyStr[0]))

    ncNodeInstance.key = key[]
    ncNodeInstance.heartbeatTimeout = ncConfig.heartbeatTimeout

    ncDPInstance = createShared(NCNodeDataProcessor)
    moveMem(ncDPInstance, dataProcessor.addr, sizeof(NCNodeDataProcessor))

proc ncInitNode*(dataProcessor: NCNodeDataProcessor, filename: string) =
    ## Initializes the node with the given configuration file.
    ncInfo(fmt("ncInitNode({fileName})"))

    let config = ncLoadConfig(fileName)
    ncInitNode(dataProcessor, config)

